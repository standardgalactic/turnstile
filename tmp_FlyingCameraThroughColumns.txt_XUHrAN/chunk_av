Cube Emitter & Particle System:
A large cube emitter is created to emit particles from its volume. Each particle uses your custom object as its instance. Rotation is enabled and configured to spin the instances based on their velocity.
Boid Physics:
Boid physics are enabled on the particle system. The boid settings are accessed via
psettings.boid_settings
, and speed/acceleration values are only set if the attributes exist in your Blender version. The standard boid rules (FOLLOW, AVOID, FLOCK) are added.
Goal & Turbulence:
A moving empty object is animated as a goal to guide the boid swarm, and a turbulence force field is added for extra chaotic motion.
Run this script in Blender’s Scripting workspace and press
Play
on the timeline. This version should avoid the attribute error and link your imported object with the boid particle locations, spinning and moving in 3D as expected. Adjust parameters as needed for your desired effect.
Dijiste:
No try something else. i am in 2.93.6 version. Lets tryin a different approach i don't need the box or emmiter any more I just want to try to import like 1000s of tetraorthodromes and places them randomly around the screen and make them bounce around using a random walk and maybe an atrractor parameter so they tend to clump up. you can try spinning as well but we don't need to use emmiters or true boids
ChatGPT dijo:
Reasoned about random movement and attraction for 14 seconds
Below is a script that completely abandons particle systems. Instead, it imports your tetraorthodrome.obj, then creates (for example) 1000 linked copies randomly placed within a volume. A frame-change handler then updates each copy each frame, applying a random walk with an attractor (toward the origin) and a little bounce if they leave the bounds. It also adds a bit of rotation (spinning) to each copy. You can tweak parameters (number of copies, bounds, factors, damping, etc.) to suit your needs.
Paste this script into Blender’s Text Editor and run it. Then press Play (or scrub the timeline) to watch the objects “bounce” around.
python
Copiar código
import
bpy
import
random
import
math
from
mathutils
import
Vector
# ---------- Clear the Scene ----------
bpy.ops.
object
.select_all(action=
'SELECT'
)
bpy.ops.
object
.delete(use_global=
False
)
# ---------- Import Your Custom Object ----------
# Specify the full path to your .obj file.
obj_path =
r"C:\Users\Mechachleopteryx\OneDrive\Documents\GitHub\Centerfuge\tetraorthodrome.obj"
bpy.ops.import_scene.obj(filepath=obj_path)
# Assume the imported object is among the selected objects.
base_obj = bpy.context.selected_objects[
0
]
base_obj.name =
"TetraorthodromeBase"
# Scale it down for the simulation.
base_obj.scale = (
0.05
,
0.05
,
0.05
)
# Hide the base so only the copies are visible.
base_obj.hide_viewport =
True
base_obj.hide_render =
True
# ---------- Create a Collection for the Copies ----------
collection = bpy.data.collections.new(
"TetraCopies"
)
bpy.context.scene.collection.children.link(collection)
# ---------- Duplicate Copies Randomly ----------
count =
1000
bounds =
20
# objects will be placed in the range (-20, 20) on each axis.
for
i
in
range
(count):
# Create a linked duplicate (sharing mesh data)
new_obj = base_obj.copy()
    new_obj.data = base_obj.data
    new_obj.name =
f"TetraCopy_
{i}
"
# Set a random starting position
new_obj.location = Vector((random.uniform(-bounds, bounds),
                                 random.uniform(-bounds, bounds),
                                 random.uniform(-bounds, bounds)))
# Give each object a random starting rotation
new_obj.rotation_euler = (random.random() *
2
* math.pi,
                              random.random() *
2
* math.pi,
                              random.random() *
2
